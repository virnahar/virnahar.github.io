<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Liquid Love | 3D Shader Experiment</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;600&display=swap');

        body { 
            margin: 0; overflow: hidden; background-color: #f0f0f0;
            font-family: 'Inter', sans-serif;
        }

        /* Agency-Style UI */
        #ui {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 40px; box-sizing: border-box;
        }

        header {
            display: flex; justify-content: space-between; align-items: flex-start;
        }

        h1 {
            font-size: 1.2rem; font-weight: 600; margin: 0; color: #1a1a1a;
            letter-spacing: -0.02em;
        }

        .meta {
            font-size: 0.8rem; color: #666; text-align: right; line-height: 1.5;
        }

        footer {
            display: flex; justify-content: space-between; align-items: flex-end;
        }

        .cta {
            font-size: 3rem; font-weight: 300; color: #1a1a1a; margin: 0;
            letter-spacing: -0.04em; line-height: 1;
            mix-blend-mode: exclusion; /* Cool overlay effect */
        }

        .scroll-txt {
            font-size: 0.8rem; color: #1a1a1a; writing-mode: vertical-rl; transform: rotate(180deg);
        }

        /* Loading Overlay */
        #loader {
            position: fixed; inset: 0; background: #fff; z-index: 100;
            display: flex; justify-content: center; align-items: center;
            transition: opacity 1s ease;
        }
    </style>
</head>
<body>

    <div id="loader">
        <div style="width: 40px; height: 1px; background: #000;"></div>
    </div>

    <div id="ui">
        <header>
            <h1>RONIK_INSPIRED // V.01</h1>
            <div class="meta">
                INTERACTIVE WEBGL<br>
                CUSTOM SHADER<br>
                VALENTINE 2026
            </div>
        </header>
        <footer>
            <div class="scroll-txt">DRAG TO ROTATE</div>
            <h2 class="cta">Spread<br>The Love</h2>
        </footer>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script type="x-shader/x-vertex" id="vertexShader">
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vViewPosition;
        uniform float uTime;
        uniform vec2 uMouse;

        // Simplex Noise Function
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
        float snoise(vec3 v) {
            const vec2 C = vec2(1.0/6.0, 1.0/3.0);
            const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i  = floor(v + dot(v, C.yyy));
            vec3 x0 = v - i + dot(i, C.xxx);
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min( g.xyz, l.zxy );
            vec3 i2 = max( g.xyz, l.zxy );
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy;
            vec3 x3 = x0 - D.yyy;
            i = mod289(i);
            vec4 p = permute( permute( permute(
                        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                    + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
            float n_ = 0.142857142857;
            vec3  ns = n_ * D.wyz - D.xzx;
            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_ );
            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
            vec4 b0 = vec4( x.xy, y.xy );
            vec4 b1 = vec4( x.zw, y.zw );
            vec4 s0 = floor(b0)*2.0 + 1.0;
            vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
            vec3 p0 = vec3(a0.xy,h.x);
            vec3 p1 = vec3(a0.zw,h.y);
            vec3 p2 = vec3(a1.xy,h.z);
            vec3 p3 = vec3(a1.zw,h.w);
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
            p0 *= norm.x;
            p1 *= norm.y;
            p2 *= norm.z;
            p3 *= norm.w;
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
        }

        void main() {
            vUv = uv;
            vNormal = normalize(normalMatrix * normal);
            
            // LIQUID DISPLACEMENT
            // We distort the vertex position based on noise and time
            float noiseVal = snoise(position * 1.5 + uTime * 0.5);
            vec3 newPos = position + normal * noiseVal * 0.3; // 0.3 is the "liquid" depth

            // Mouse Interaction (Ripple)
            float dist = distance(uv, uMouse);
            float ripple = sin(dist * 10.0 - uTime * 2.0) * 0.1 * (1.0 - smoothstep(0.0, 0.5, dist));
            newPos += normal * ripple;

            vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);
            vViewPosition = -mvPosition.xyz;
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShader">
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vViewPosition;
        uniform float uTime;

        void main() {
            vec3 viewDir = normalize(vViewPosition);
            vec3 normal = normalize(vNormal);

            // COLOR PALETTE (The "Ronik" Pink/Red/Orange gradient)
            vec3 colorA = vec3(1.0, 0.2, 0.4); // Deep Pink
            vec3 colorB = vec3(1.0, 0.6, 0.2); // Golden Orange
            
            // Fresnel Effect (Rim Lighting for "Glassy" look)
            float fresnel = dot(viewDir, normal);
            fresnel = clamp(1.0 - fresnel, 0.0, 1.0);
            fresnel = pow(fresnel, 3.0);

            // Mix colors based on normal and time
            float mixVal = dot(normal, vec3(0.5, 0.5, 0.0)) * 0.5 + 0.5;
            vec3 baseColor = mix(colorA, colorB, mixVal + sin(uTime)*0.1);

            // Add Specular Highlight (The "Shiny" liquid look)
            vec3 lightDir = normalize(vec3(1.0, 1.0, 2.0));
            vec3 reflectDir = reflect(-lightDir, normal);
            float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);

            // Final Composition
            vec3 finalColor = baseColor + vec3(fresnel) * 0.8 + vec3(spec);
            
            gl_FragColor = vec4(finalColor, 1.0);
        }
    </script>

    <script>
        // --- 1. SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f0f0); // Soft grey-white background

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 12;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- 2. THE LIQUID HEART ---
        // We create a "Parametric Heart" but with high subdivision for the liquid shader to work
        function heartFunction(u, v, target) {
            u = u * Math.PI * 2;
            v = v * Math.PI;
            
            let x = 16 * Math.pow(Math.sin(u), 3);
            let y = 13 * Math.cos(u) - 5 * Math.cos(2*u) - 2 * Math.cos(3*u) - Math.cos(4*u);
            let z = v * 5; // Thickness

            // Squeeze it into a 3D volume (The mathematical heart is 2D surface, we extrude/bloat it)
            // Using a sphere mapping distorted by heart formula
            const r = 1.5;
            x = r * 16 * Math.pow(Math.sin(u), 3) * Math.sin(v);
            y = r * (13 * Math.cos(u) - 5 * Math.cos(2*u) - 2 * Math.cos(3*u) - Math.cos(4*u)) * Math.sin(v);
            z = r * 10 * Math.cos(v);

            target.set(x * 0.1, y * 0.1, z * 0.1);
        }

        // Using a high-res Sphere geometry and modifying it looks cleaner for liquid simulation
        const geometry = new THREE.SphereGeometry(3, 128, 128); 
        
        // Morph the sphere into a heart initially
        const pos = geometry.attributes.position;
        const v3 = new THREE.Vector3();
        for (let i = 0; i < pos.count; i++) {
            v3.fromBufferAttribute(pos, i);
            // Simple Heart Distortion Math
            let x = v3.x; let y = v3.y; let z = v3.z;
            y -= 1.0; // Shift down
            // Taper bottom
            x *= 1.0 + (y*0.1); 
            z *= 0.5 + (y*0.1);
            // Dip top
            if(y > 0) {
                x *= (1.0 - y*0.2);
                z *= (1.0 - y*0.2);
                y -= Math.abs(x)*0.5 * Math.pow((y), 0.5); // The cleave
            }
            pos.setXYZ(i, x, y, z);
        }
        geometry.computeVertexNormals();

        // --- 3. CUSTOM SHADER MATERIAL ---
        const material = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent,
            uniforms: {
                uTime: { value: 0 },
                uMouse: { value: new THREE.Vector2(0.5, 0.5) }
            },
            wireframe: false
        });

        const liquidHeart = new THREE.Mesh(geometry, material);
        scene.add(liquidHeart);

        // --- 4. FLOATING PARTICLES (Agency Dust) ---
        const particlesGeo = new THREE.BufferGeometry();
        const particlesCount = 200;
        const pPos = new Float32Array(particlesCount * 3);
        for(let i=0; i<particlesCount*3; i++) pPos[i] = (Math.random()-0.5) * 20;
        particlesGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
        const particlesMat = new THREE.PointsMaterial({ color: 0x000000, size: 0.05, transparent: true, opacity: 0.2 });
        const particleSystem = new THREE.Points(particlesGeo, particlesMat);
        scene.add(particleSystem);

        // --- 5. INTERACTION & ANIMATION ---
        let mouse = { x: 0, y: 0 };
        let targetRotation = { x: 0, y: 0 };

        window.addEventListener('mousemove', (e) => {
            // Normalize mouse -1 to 1
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            // Pass to shader (0 to 1)
            material.uniforms.uMouse.value.x = e.clientX / window.innerWidth;
            material.uniforms.uMouse.value.y = 1.0 - (e.clientY / window.innerHeight);
        });

        window.addEventListener('touchmove', (e) => {
            const touch = e.touches[0];
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
            material.uniforms.uMouse.value.x = touch.clientX / window.innerWidth;
            material.uniforms.uMouse.value.y = 1.0 - (touch.clientY / window.innerHeight);
        });

        // Intro Animation
        window.onload = () => {
            document.getElementById('loader').style.opacity = 0;
            setTimeout(() => document.getElementById('loader').remove(), 1000);
            
            gsap.from(liquidHeart.scale, { x:0, y:0, z:0, duration: 2, ease: "elastic.out(1, 0.5)" });
        };

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // Update Shader Uniforms
            material.uniforms.uTime.value = time;

            // Smooth Rotation (Lag effect)
            targetRotation.x = mouse.y * 0.5;
            targetRotation.y = mouse.x * 0.5;

            liquidHeart.rotation.x += (targetRotation.x - liquidHeart.rotation.x) * 0.05;
            liquidHeart.rotation.y += (targetRotation.y - liquidHeart.rotation.y) * 0.05;

            // Gentle float
            liquidHeart.position.y = Math.sin(time * 0.5) * 0.2;

            // Particles float
            particleSystem.rotation.y += 0.001;

            renderer.render(scene, camera);
        }

        animate();

        // Resize Handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
